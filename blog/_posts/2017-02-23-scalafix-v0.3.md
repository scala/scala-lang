# Refactor with scalafix

We are happy to announce the release of [scalafix v0.3][scalafix].
This release introduces a new `Rewrite` and `Patch` API powered by the [scala.meta semantic API][meta-1.6].
We are excited about this release because we believe it enables a number promising tooling applications.

Scala.meta recently had its first release of its semantic API; the semantic API provides operations to query information from the compiler.
This has enabled rewrites in scalafix to query for the so-called "symbol" of a name that appears in a Scala source file.
A symbol is a unique identifier of a definition such as a class, val, def or trait.
This ability to query for symbols opens possibilities for a great number of refactorings including imports management and identifier renaming.

The long-term mission of scalafix is to help automate the migration of deprecated Scala 2.x features to Dotty.
However, scalafix can be used for more than migrating between Scala versions; it can also be used for ad-hoc library and application migrations.
To demonstrate what rewrites can be implemented with scalafix v0.3, let's step through an example of a real usecase.

## Example: Xor to Either

The functional programming library [cats][cats] migrated recently from its `Xor` data type to `Either` from the standard library.
It requires a few mechanical steps to migrate code to use `Either` instead of `Xor`.
For example, below is a diff that's taken from [circe][xor-cire]'s migration to `Either`.

```diff
-  final def either: Xor[HCursor, HCursor] = if (succeeded) Xor.right(any) else Xor.left(any)
+  final def either: Either[HCursor, HCursor] = if (succeeded) Right(any) else Left(any)
```

Scalafix rewrites are composed of so-called "patches".
A patch describes a single refactoring operation.
`Replace` is one patch that can be used to rename identifiers

```scala
Replace(Symbol("_root_.cats.data.Xor."), q"Either")
Replace(Symbol("_root_.cats.data.Xor.Left."), q"Left")
Replace(Symbol("_root_.cats.data.Xor.Right."), q"Right")
```

The `Symbol(_root_...data.Xor)` part is the scala.meta symbol referencing the class definition of `cats.data.Xor`.
As we saw in the `either: Xor[HCursor` diff above, references to `Xor` should become `Either` after the rewrite.

To introduce new imports on rename, it's possible to pass in `additionalImports`
```scala
Replace(Symbol("_root_.cats.data.XorT."), q"EitherT",
        additionalImports = List(importer"cats.data.EitherT")),
```

Imports can be removed with the `RemoveGlobalImport` patch

```scala
RemoveGlobalImport(importer"cats.data.Xor")
```
Nothing happens if the import does not appear in the source file.
Likewise, it's OK to add the same import twice, scalafix will de-duplicate it.

The full `Xor` to `Either` scalafix rewrite can be found [here][xor2either] and its accompanying test
suite [here][xor2either-test].

To learn more about how to start with scalafix, visit the [installation docs][install]!

## Cross-building

TODO: Shane

## Custom rewrites
You can write your own custom rewrites.

[xor2either-test]: https://github.com/scalacenter/scalafix/blob/f61136fad79afcdbb03528ce78c7928afc6eafd6/scalafix-nsc/src/test/resources/syntactic/Xor2Either.source
[xor2either]: https://github.com/scalacenter/scalafix/blob/f61136fad79afcdbb03528ce78c7928afc6eafd6/core/src/main/scala/scalafix/rewrite/Xor2Either.scala
[xor-circe]: https://github.com/circe/circe/pull/343/files
[cats]: http://github.com/typelevel/cats
[ghpages]: http://github.com/scalacenter/scalafix
[prevpost]: http://scala-lang.org/blog/2016/10/24/scalafix.html
[scalafix]: https://scalacenter.github.io/scalafix/#0.3.0
[install]: https://scalacenter.github.io/scalafix/#Installation
[meta-1.6]: https://github.com/scalameta/scalameta/blob/master/changelog/1.6.0.md#semantic-api
