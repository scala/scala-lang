---
category: release
permalink: /news/3.7.0/
title: "Scala 3.7.0 released!"
by: Wojciech Mazur, VirtusLab
---

![Scala 3.7]({{ site.baseurl }}/resources/img/scala-3.7-launch.png)

We're excited to announce the release of Scala 3.7.0 ‚Äî a significant minor release that brings stabilized SIPs, powerful new features, expanded platform support, and notable improvements to tooling and compatibility.

# What‚Äôs new in Scala 3.7?

## Stabilised SIPs

### [SIP-52: Binary APIs](https://docs.scala-lang.org/sips/binary-api.html)

Scala 3.7.0 stabilizes the @publicInBinary annotation, introduced experimentally in Scala 3.4. This annotation ensures binary compatibility when inline methods access non-public members and prevent generation of redundant accessors required by inlining mechanism.

Inline methods are always inlined at their call sites. If they refer to members not visible outside their defining scope, the compiler generates accessor methods. The accessors are not subject to binary compatibility, these might be emitted differently by newer versions of compiler or eventually removed.
The `@publicInBinary` annotation addresses this by emitting those members as public in bytecode, while maintaining restricted source-level visibility.
 This allows the compiler to refer to the original non-private member without the need to create additional accessors.

```scala
object api:
  class Service:
    private[api] def implementation(): Unit = println("Executing old API")
    inline def use() = implementation()
    // generated by compiler, accessed in `use()`
    // def api$Service$$inline$implementation(): Unit = implementation()
  
  class Consumer:
    inline def consume() = api.Service().implementation()
    // generated by compiler, accessed in `consume()`
    // def inline$implementation$i1(x$0: api$Service) = x$0.implementation()
    
    @scala.annotation.publicInBinary
    private[api] var isActive: Boolean = false
    inline def isStale = !isActive 
```

The new annotation also resolves a long-standing issue with the inability to invoke a private constructor of a class from inlined methods. Now by annotating the constructor with `@publicInBinary` you are allowed to access it directly from inlined methods.

```scala
import scala.annotation.publicInBinary

class Printer @publicInBinary private(id: Int)
object Printer:
  inline def create(): Printer = new Printer(42) // Not allowed previously
```

SIP-52 has also introduced the linting flag `-WunstableInlineAccessors` which detects and emits warnings for all unstable accessors generated for inline methods. This flag has been available since Scala 3.4.0. We highly recommend its usage of users' codebases, especially in the case of public libraries.

### [SIP-58: Named Tuples](https://docs.scala-lang.org/sips/named-tuples.html)

Named Tuples introduced as experimental in Scala 3.5 are now a stable feature.
Named tuples are a convenient lightweight way to return multiple results from a function or to model the data using tuples while allowing you to use meaningful names for its fields.

```scala
@main def meaningfullReturnTypes =
  extension [T](seq: Seq[T])
    inline def partitionBy(predicate: PartialFunction[T, Boolean]): (matching: Seq[T], unmatched: Seq[T]) =
      seq.partition(predicate.unapply(_).getOrElse(false))

  List(
    (x = 1, y = 0),
    (x = 2, y = 3),
    (    3,    0,),
  ).partitionBy:
    case (x = x, y = 0) => x < 5
  .matching.map(_.x)
  .foreach(println)
  
  val measurements = List[(location: String, value: Double)](
 ("Lousanne",  8.05),
 ("London",      21),
 ("Rome",      37.0),
 )
  val average = measurements.map(_.value).sum / measurments.size
```

What's more, this feature also enhances other existing features - it is now possible to match on subset of case class fields by referring to its fields by name. By doing so you no longer need to specify a long list of wildcard selectors for each field of a large case class.

```scala
@main def selectiveClassExtractors = 
  type Timestamp = Long
  type OrderId = String
  type ItemId = Long

  case class Order(
    id: OrderId,
    createdAt: Timestamp,
    shippedAt: Option[Timestamp] = None,
    deliveredAt: Option[Timestamp] = None,
    itemIds: List[ItemId] = Nil
  )
  
  val orders = List.empty[Order]
  val selected = orders.collect:
    case Order(id = s"special-${internalId}", shippedAt = None) => internalId
    case Order(id = orderId, itemIds = items) if items.size > 5 => orderId
```

Last, but not least, named tuples are opening a new paradigm of metaprogramming by letting you compute structural types without the need for macros!
The `Selectable` trait now has a `Fields` type member that can be instantiated to a named tuple.

```scala
class QueryResult[T](rawValues: Map[String, Any]) extends Selectable:
  type Fields = NamedTuple.Map[NamedTuple.From[T], Option]
  def selectDynamic(fieldName: String) = rawValues.get(fieldName)
  
case class Release(version: String, issues: List[String])

@main def Test =
  val query: QueryResult[Release] = QueryResult(Map("version" -> "3.7.0"))
  val version: Option[String] = query.version
  assert(query.version.contains("3.7.0"))
  assert(query.issues.isEmpty)
```

## Preview SIPs

### Preview features

Scala 3.7 introduces the concept of `preview` features ‚Äî fully implemented and SIP-approved, but potentially subject to small refinements.
New Scala language features or standard library APIs are initially introduced as experimental, but once they become fully implemented and accepted by the [SIP](https://docs.scala-lang.org/sips/) these can become a `preview` feature.

Preview language features and APIs are guaranteed to be standardized in some next Scala minor release, but allow the compiler team to introduce small, possibly binary incompatible, changes based on the community feedback.
These can be used by early adopters who can accept the possibility of binary compatibility breakage. For instance, preview features could be used in some internal tool or application. On the other hand, preview features are discouraged in publicly available libraries.

All preview features can be enabled using `-preview` flag passed to the compiler. More information about preview features can be found in [preview definitions guide](https://docs.scala-lang.org/scala3/reference/preview/overview.html)

### [SIP-62: For comprehension improvements](https://docs.scala-lang.org/sips/better-fors.html)

The first introduced preview feature is [SIP-62 - `Better Fors`](https://docs.scala-lang.org/sips/better-fors.html) originally introduced in Scala 3.6 as an experimental.
A major user-facing improvement introduced by this SIP is the ability to start a for-comprehension block with aliases.
It also introduces changes to how your code is desugared by the compiler, leading to a more optimized code by removing some redundant calls.

```scala
//> using options -preview
//> using scala 3.7
@main def betterFors = 
  for
    a = 1
    b <- Some(2)
    c <- Option.when(a < 5)(10)
  yield b * c
```

We encourage users to try out this feature which is likely going to be stabilised in Scala 3.8.

## New experimental SIPs

### [SIP-61: Unroll Default Arguments for Binary Compatibility](https://docs.scala-lang.org/sips/unroll-default-arguments.html)

Scala case classes were for a long time avoided when defining a public API since each change to the list of their fields affected their binary compatibility. This was typically observed whenever a new field was added to the case class primary constructor, even if it was defined with a default value to resolve source compatibility problems. Even though binary compatibility issues were typically detected when using [MiMa](https://github.com/lightbend/mima), you were still required to manually create shim methods to match the old signatures of the methods.

The `@unroll` annotation is going to eliminate this long-standing issue. This annotation lets you add additional parameters to method `def`s, `class` constructors, or `case class`es, without breaking binary compatibility. `@unroll` works by generating ‚Äúunrolled‚Äù or ‚Äútelescoping‚Äù forwarders, ensuring your code will maintain binary compatibility as new default parameters and fields are added over time.

```scala
//> using scala 3.7
//> using options -experimental

import scala.annotation.unroll

case class Product(
    name: String,
    price: BigDecimal,
    @unroll description: Option[String] = None,
){
  // generated by compiler:
  // def this(name: String, price: BigDecimal) = this(name, price)
  // def copy(name: String, price: BigDecimal) = this(name, price)
}

object Factory:
  def processOrder(
      products: List[Product],
      @unroll quantity: Int = 1,
      @unroll discount: Int = 0
  ): Unit = ???

  // generated by the compiler:
  // def processOrder(products: List[Product]): Unit = processOrder(products)
  // def processOrder(products: List[Product], quantity: Int): Unit = processOrder(products, quantity)
```

More details can be found in [`@unroll` reference](https://docs.scala-lang.org/scala3/reference/experimental/unrolled-defs.html)

### [SIP-68: Reference-able Package Objects](https://github.com/scala/improvement-proposals/pull/100)

One limitation with `package object`s is that we cannot currently assign them to values directly even though it is possible for normal `object`s. The workaround is to use a special ".`package`" accessor, but this is ugly and non-obvious. Or one could use a normal `object`, which is not always possible.

SIP-68: Reference-able Package Object drops this limitation, by automatically referring to package object value whenever it's assigned to a variable.

```scala
//> using scala 3.7
//> using options -experimental

package my.pkg
import scala.language.experimental.packageObjectValues

package object releases:
  val `3.7` = "3.7.0" 
  
@main def referencablePkgObject = 
  val versions = my.pkg.releases
  val oldStyle = my.pkg.releases.`package`
  println(versions.`3.7`)
```

For more details visit the [reference page](https://docs.scala-lang.org/scala3/reference/experimental/package-object-values.html) of this feature.

## Other notable changes

### New scheme for given prioritization

In the [Scala 3.5.0 release notes](https://scala-lang.org/blog/2024/08/22/scala-3.5.0-released.html) we've announced upcoming changes to givens, due to their peculiar problem with prioritization. Under the old rules, the compiler always tried to select the instance with the most specific subtype of the requested type. Under the new rules, it would change to always selecting the instance with the most general subtype that satisfies the context-bound.
Starting from Scala 3.7 compiled would use the new behaviour by default.
Running the compiler with `-source:3.5` will allow you to temporarily keep using the old rules.
Under `-source:3.7-migration`, code whose behaviour differs between new and old rules (ambiguity on new, passing on old, or vice versa) will emit warnings, but the new rules will still be applied.

For the detailed motivation of changes with examples of code that will be easier to write and understand, see our recent blog post - [Upcoming Changes to Givens in Scala 3.7]({{ site.baseurl }}/2024/08/19/given-priority-change-3.7.html).

### Expression Compiler is now part of Scala 3 compiler [#22597](https://github.com/scala/scala3/pull/22597)

The expression compiler powers the debug console in Metals and the IntelliJ Scala plugin, enabling the evaluation of arbitrary Scala expressions at runtime (even macros). The expression compiler produces class files that can be loaded by tooling to compute the evaluation output.
Previously expression compiler was developed independently from the Scala compiler inside [scalacenter/scala-debug-adapter](https://github.com/scalacenter/scala-debug-adapter) repository and was cross-published for every Scala release.
Starting with Scala 3.7 the expression compiler has been migrated to the main [scala/scala3](https://github.com/scala/scala3) repository and become an integral part of Scala toolchain. This change would allow users to use expression compiler with nightly versions of the compiler as well and it would ease the maintenance and releasing process for the compiler team.

### Presentation Compiler: Show inferred type on holes in hover [#21423](https://github.com/scala/scala3/pull/21423)

The presentation compiler is a specialized instance of the Scala compiler that runs interactively in IDEs or LSPs, providing immediate feedback about code correctness, type checking, symbol resolution, autocompletion, error highlighting, and other editing support functionalities.
Some of the latest improvements to the presentation compiler focus on the ability to infer more information about expected types of expressions provided by the users. As the results presented compiler can now show the users the expected type of expression when hovering over holes.

### Quotes API changes

Scala 3.7 introduces changes to the experimental subset of Quotes API. One notable addition is the `apply` methods to import selectors ([#22457](https://github.com/scala/scala3/pull/22457)), simplifying the construction of import statements within macros. This feature streamlines the generation of import trees, making macro code more concise and readable.‚Äã

Another advancement is the experimental `summonIgnoring` method ([#22417](https://github.com/scala/scala3/pull/22417)). It allows developers to summon implicit instances while excluding specific instances of givens from the search. It's particularly useful in complex derivation scenarios where certain implicit should be disregarded to prevent conflicts or unintended resolutions.‚Äã It might be used to provide a custom implementation of macro only in cases where a user-defined variant of implicit is defined.

```scala
//> using options -experimental

import scala.quoted.*

trait ExcludedType
trait Show[T]:
  def show(): Unit

object Show {
  implicit transparent inline def auto[T]: Show[T] = ${ autoImpl[T] }

  private def autoImpl[T: Type](using Quotes): Expr[Show[T]] =
    import quotes.reflect.*
    Expr.summonIgnoring[Show[ExcludedType]](
      // Ignore implicits produced by these symbols:
      Symbol.classSymbol("Show").companionModule.methodMember("auto")*
    ) match
      case Some(instance) =>
        // User provided their own instance of `Show[ExcludedType]` - use it 
        '{
          new Show[T]:
            def show(): Unit =
              println(s"Show[${${ Expr(TypeRepr.of[T].show) }}] including user defined Show[ExcludedType]:")
              $instance.show()
        }
      case None =>
        // No user-defined implicit for `Show[ExcludedType]` beside `Show.auto`
        '{
          new Show[T]:
            def show(): Unit =
              println(s"Show[${${ Expr(TypeRepr.of[T].show) }}]")
        }
}
```

Furthermore, the `Quotes.newClass` method has been extended to support class parameters, flags, privateWithin, and annotations ([#21880](https://github.com/scala/scala3/pull/21880)). This enhancement enables the dynamic creation of classes with constructors, access modifiers, and annotations, providing greater control over generated code structures.

### Improvements to `-Wunused` and `-Wconf` [#20894](https://github.com/scala/scala3/pull/20894)

Scala 3.7 introduces a significant enhancement to its linting mechanism by revamping the `CheckUnused` compiler phase. Previously, developers encountered false-positive warnings when importing givens, particularly when they were defined in shared traits across multiple objects. This issue often led to unnecessary code restructuring or the disabling of linting checks.‚Äã

The updated implementation leverages the `MiniPhase` API, aligning the linting process more closely with the compiler's contextual understanding. This change ensures that the compiler accurately identifies genuinely unused imports, thereby reducing misleading warnings.
Additionally, the update introduces support for `-Wunused:patvars`, enabling warnings for unused pattern variables.
Changes also enhance the `-Wconf` option to allow origin-based filtering `-Wconf:origin=full.path.selector` as in Scala 2. That allows, for example, to exclude certain blessed imports from warnings, or to work around false positives:

```scala
-Wconf:origin=scala.util.chaining.given:s
```

These improvements collectively provide developers with more precise and configurable linting tools, enhancing code quality and maintainability.‚Äã

### Implicit parameters now warn at call site without `using` keyword [#22441](https://github.com/scala/scala3/pull/22441)

As part of Scala's ongoing migration from the older implicit syntax to the newer, clearer given and using syntax, Scala 3.7 introduces a change regarding method calls involving implicit parameters. Now, explicitly providing arguments to methods defined with implicit parameters without the `using` keyword emits a compiler warning at the call site. This adjustment reduces ambiguity inherent in Scala 2 syntax, where it was unclear whether an explicitly provided argument was intended for an implicit parameter or for the apply method of the resulting object.

```scala
trait Config
object Config:
  def default: Config = ???
  
def implicitBased(implicit config: Config) = ???
def givenBased(using Config) = ???

@main def explicitImplicits = 
  implicitBased(Config.default)       // warning: Implicit parameters should be provided with a `using` clause.
  implicitBased(using Config.default) // recommended
  
  givenBased(Config.default)       // error: Would not compile without `using``
  givenBased(using Config.default)
```

Scala 3.7 provides an automated migration path for existing codebases through the compiler flags -rewrite -source:3.7-migration, which automatically inserts the recommended `using` keywords, streamlining the transition to the new syntax.

### Scala 3 unblocked on Android [#22632](https://github.com/scala/scala3/pull/22632)

Scala 3.7 brings a crucial fix that enhances its compatibility with the Android platform. Previously, developers faced issues when compiling Scala 3 code for Android due to the Android Runtime (ART) enforcing stricter type constraints on lambda expressions compared to the standard Java Virtual Machine (JVM). Specifically, ART requires that the return type of a Single Abstract Method (SAM) interface be a primitive type or explicitly boxed, a condition not mandated by the JVM.‚Äã

The update addresses this by modifying the Scala compiler to box the return type of native instantiated methods when the SAM's return type isn't primitive. This change ensures that lambda expressions conform to ART's expectations, preventing runtime errors on Android devices. By aligning the compiler's behaviour with ART's requirements, the Scala 3 development for the Android platform should be unblocked, although it might require recompiling existing libraries using Scala 3.7 or the upcoming Scala 3.3 LTS version containing a backported fix.

### Minimal support for dependant case classes [#21698](https://github.com/scala/scala3/pull/21698)

Starting with Scala 3.7, developers can now define case classes with dependent fields, marking a notable improvement in expressiveness and type safety. This allows fields within a case class to depend on other constructor parameters via path-dependent types. One use case is encoding a configuration system where each setting has a distinct value type determined by the setting itself.

```scala
case class ConfigEntry(option: Setting, default: option.Value):
  def value(using Context): option.Value = option.userDefined.getOrElse(default)

trait Context
trait Setting(val name: String):
  type Value
  def userDefined(using Context): Option[Value] = None

class StringSetting(name: String) extends Setting(name):
  override type Value = String

class IntSetting(name: String) extends Setting(name):
  override type Value = Int


@main def DependantCaseClasses =
  given Context = new {}
  val settings = List[ConfigEntry](
    ConfigEntry(StringSetting("docs.page"), "https://docs.scala-lang.org/"),
    ConfigEntry(IntSetting("max.threads"), 32)
  )
```

This enhancement simplifies type-safe heterogeneous collections and makes it easier to express advanced design patterns previously requiring workarounds or more verbose type definitions.

### Dependency updates

#### Scala 2 Standard Library

Scala 3 now defaults to the [Scala 2.13.16](https://github.com/scala/scala/releases/tag/v2.13.16) Standard Library. Be mindful of breaking changes and deprecations introduced since 2.13.15:

* On the empty string, `.tail` and `.init` now throw (instead of returning the empty string) [#10851](https://github.com/scala/scala/pull/10851)
* Do not use `rangeHash` when `rangeDiff` is 0 [#10912](https://github.com/scala/scala/pull/10912)
* Deprecate `collection.mutable.AnyRefMap` [#10862](https://github.com/scala/scala/pull/10862)

#### Scala.js

Scala.js has been updated from version 1.16.0 to 1.19.0. Libraries published using Scala 3.7 must use Scala.js 1.19.0 or later. Key improvements include:

* Native support for JavaScript `async/await`, through `js.async { ... }` and `js.await(...)`
* Small code size improvements for the JavaScript target when using SAM lambdas.
* For Wasm only: support for the JavaScript Promise Integration feature (JSPI).

Please refer to Scala.js changelogs for more details:

* [Scala.js 1.17.0](https://www.scala-js.org/news/2024/09/28/announcing-scalajs-1.17.0)
* [Scala.js 1.18.1](https://www.scala-js.org/news/2025/01/09/announcing-scalajs-1.18.1)
* [Scala.js 1.18.2](https://www.scala-js.org/news/2025/01/23/announcing-scalajs-1.18.2)
* [Scala.js 1.19.0](https://www.scala-js.org/news/2025/04/21/announcing-scalajs-1.19.0)

#### Scala CLI

Scala runner has been updated and uses now Scala CLI 1.7.1.
The new Scala runner uses `scalafmt` binaries built using Scala Native for `fmt` subcommand, this change can improve the performance of formatting Scala sources. It also includes experimental support for running `scalafix` rules using `scala fix` subcommand.

Please refer to Scala CLI changelogs for more details:

* [Scala CLI 1.6.0](https://github.com/VirtusLab/scala-cli/releases/tag/v1.6.0)
* [Scala CLI 1.6.1](https://github.com/VirtusLab/scala-cli/releases/tag/v1.6.1)
* [Scala CLI 1.7.0](https://github.com/VirtusLab/scala-cli/releases/tag/v1.7.0)
* [Scala CLI 1.7.1](https://github.com/VirtusLab/scala-cli/releases/tag/v1.7.1)

# What‚Äôs next?

With the final release of Scala 3.7.0, the first patch version‚ÄîScala 3.7.0-RC1‚Äîhas already been made available. This release includes additional fixes and improvements introduced after the branch cutoff.

Looking ahead, you can expect two more patch releases before Scala 3.8, which is scheduled for release in September this year. The goal for Scala 3.8 is to be the last minor version before the next Long-Term Support (LTS) release, Scala 3.9, which is planned for early next year.

The Scala compiler team aims to finalize all major changes in 3.8, followed by a soft feature freeze and a stabilization period. This ensures a smooth transition for users and maximizes the stability of the compiler and tooling ecosystem ahead of the LTS release.


# Contributors

Thank you to all the contributors who made this release possible üéâ

According to `git shortlog -sn --no-merges 3.6.4..3.7.0` these are:

```
  63  Martin Odersky
  47  Som Snytt
  33  Adrien Piquerez
  32  Hamza Remmal
  29  Wojciech Mazur
  19  aherlihy
  19  kasiaMarek
  16  Jan Chyb
  13  Dale Wijnand
  11  Kacper Korban
  10  EnzeXing
   9  S√©bastien Doeraene
   7  Guillaume Martres
   7  Matt Bovel
   7  Oliver Braƒçevac
   7  noti0na1
   5  HarrisL2
   5  Jamie Thompson
   5  dependabot[bot]
   4  Joel Wilsson
   4  Piotr Chabelski
   4  Seth Tisue
   3  Roman Janusz
   3  anna herlihy
   2  David Hua
   2  Tomasz Godzik
   2  Yichen Xu
   1  Alec Theriault
   1  Daisy Li
   1  Daniel Thoma
   1  Dmitrii Naumenko
   1  Felix Herrmann
   1  He-Pin(kerr)
   1  Jo√£o Ferreira
   1  Jƒôdrzej Rochala
   1  Katarzyna Marek
   1  Kenji Yoshida
   1  Natsu Kagami
   1  Niklas Fiekas
   1  Rocco Mathijn Andela
   1  Vadim Chelyshov
   1  adpi2
   1  fan-tom
   1  philwalk
   1  rochala
```

For a full list of changes and contributor credits, please refer to the [release notes](https://github.com/scala/scala3/releases/tag/3.7.0).
