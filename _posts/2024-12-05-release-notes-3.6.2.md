---
category: announcement
permalink: /news/3.6.2
title: "Scala 3.6.2 is now available!"
---

![Scala 3.6]({{ site.baseurl }}/resources/img/scala-3.6-launch.jpg)

We're happy to announce the next minor release of Scala - 3.6.2 is finally out!

# What happened to Scala 3.6.0 and 3.6.1?

During the release of 3.6.0-RC1, an accident caused the publishing of artefacts versioned as 3.6.0 to the immutable Maven repository.
To mitigate possible damage we've released a hotfix release 3.6.1 to prevent automatic tooling from using a broken version of the compiler.
Versions 3.6.0 (a broken release) and 3.6.1 (a hotfix release) should never be used.
The incident was described in detail at [Scala 3.6.0 Post Mortem blogpost](https://www.scala-lang.org/news/post-mortem-3.6.0.html).

Scala 3.6.2 should effectively be regarded as "3.6.0" for all intents and purposes.
We apologize to the Scala users for any inconvenience it might have caused.

# Whatâ€™s new in Scala 3.6?

Besides multiple bugfixes, this release stabilises multiple experimental features introduced to the Scala language after careful review and acceptance by the [Scala Improvement Proposal's Commitee](https://docs.scala-lang.org/sips/). Many of these changes can have a significant impact on the Scala syntax and are introducing new possibilities in writing concise, typesafe as well as easier, and easier to maintain code.

## SIP-47 - Clause Interleaving

The first major feature we're going to cover is the [clause interleaving](https://docs.scala-lang.org/sips/clause-interleaving.html).
With this change to the language, you're able to define multiple type parameter lists or place them after the first arguments list. Clause interleaving would benefit the path-dependent API creators.

```scala
trait Key { type Value }
trait DB {
  def getOrElse(k: Key)[V >: k.Value](default: V): V // dependent type parameter
}
```

## SIP-64 - Improve Syntax for Context Bounds and Givens

This release stabilises the [SIP-64](https://docs.scala-lang.org/sips/sips/typeclasses-syntax.html) introduced as experimental in Scala 3.5.0. These changes provide you with the new syntax for defining type class instances.
The goal of these changes is to simplify and narrow the syntax rules required to create a given instance. To name a few:

- you can now replace the `with` keyword with `:` when defining simple type classes,
- context bounds can now be named and aggregated using `T : {A, B}` syntax,
- conditional givens can also be defined with parameters
- by-name givens can be defined using conditional given with empty parameters list

```scala
trait Order[T]:
  extension (values: Seq[T]) def toSorted: Seq[T] = ???
  def compare(x: T, y: T): Int

// No need for `with` keyword
given Order[Int]:
  def compare(x: Int, y: Int): Int = ???

// Named given instance using named context bound parameter
given listOrdering: [T: Order as elementOrder] => Order[List[T]]:
  def compare(x: List[T], y: List[T]): Int = elementOrder.compare(x.head, y.head)

trait Show[T]:
  extension (value: T) def asString: String

// Aggregated context parameters
def showOrdered[T: {Order as unusedName, Show}](values: Seq[T]): Unit =
  values.toSorted.map(_.asString).foreach(println)

// Conditional givens where a contextual instance of Config is required to create an instance of Factory
trait Config
trait Factory
class MemoizingFactory(config: Config) extends Factory
given (config: Config) => Factory = MemoizingFactory(config)

// By-name given
trait Context
given context: () => Context = ???
```

Other changes to type classes involve the stabilisation of context bounds for type members.
This mechanism allows defining an abstract given instance that needs to be provided by a class implementing the trait that defines an abstract given.

```scala
trait Collection:
  // abstract member context-bound
  type Element: Order

class List[T: Order] extends Collection:
  type Element = T
  // given Order[Element] = ev$1 // generated by compiler, uses class context bound

class Set[T] extends Collection:
  type Element = T
  override given Order[Element] = ??? // custom implementation provided by the user
```

See the updated [Contextual Abstractions](https://scala-lang.org/api/3.6.2/docs/docs/reference/contextual/givens.html) chapter of the Scala 3 reference guide to learn more about these changes.

_**Note**: It is important not to confuse changes under SIP-64 with the [experimental modularity improvements](https://dotty.epfl.ch/docs/reference/experimental/typeclasses.html) available under `-language:experimental.modularity` and `-source:future`. These changes are still being developed in the experimental phase and would require SIP committee acceptance before stabilisation.

## SIP-56 Amendment: Match types extractors follow aliases and singletons

Scala 3.6 also stabilises the improvements of match types previously available under `-language:experimental.betterMatchTypeExtractors`. These changes were amending the match type specification and adjusting the implementation of match types under [SIP-56](https://docs.scala-lang.org/sips/match-types-spec.html) to resolve some of the issues reported by users. Under the new rules, it is possible to correctly resolve aliases and singleton types.

```scala
trait A:
  type T
  type U = T

trait B extends A:
  type T = String

type F[X] = A { type U = X }
type InvF[Y] = Y match
  case F[x] => x

def Test = summon[InvF[B] =:= String] // was error: selector B does not uniquely determine parameter x
```

## Experimental SIP-62 - For-Comprehension Improvements

Starting with Scala 3.6.2 you can take advantage of improvements to the for-comprehensions syntax.  
Major user-facing improvement introduced by [SIP-62](https://docs.scala-lang.org/sips/better-fors.html) is the ability to start a for-comprehension block with aliases:

```scala
//> using options -experimental -language:experimental.betterFors
@main def betterFors = 
  for
    a = 1
    b <- Some(2)
    c <- Option.when(a < 5)(10)
  yield b * c
```

It also introduces changes to how your code is desugared by the compiler, leading to a more optimized code by removing some redundant calls.

## Experimental SIP-57 - Replace non-sensical `@unchecked` annotations

One of the new, experimental, features is the implementation of [SIP-57](https://docs.scala-lang.org/sips/replace-nonsensical-unchecked-annotation.html) introducing a `runtimeChecked` extension method replacing some usages of `@unchecked` annotation using a more convenient syntax. A common use case for `runtimeChecked` is to assert that a pattern will always match, either for convenience or because there is a known invariant that the types can not express.

Some typical use cases might be looking up an expected entry in a dynamically loaded dictionary-like structure:

```scala
trait AppConfig:
  def get(key: String): Option[String]
val config: AppConfig = ???

val Some(appVersion) = config.get("appVersion").runtimeChecked
```

# Other notable changes

## Switch mapping of context bounds to using clauses

Until Scala 3.6 context bound parameters were always desugared to `implicit` arguments, starting with Scala 3.6 these would be mapped to `using` parameters instead.
This change should not affect the majority of users, however, it can lead to differences in how implicits are resolved.
Resolution of implicits can slightly differ depending on whether we're requesting them using `implicit` or `using` parameter, or depending on whether they were defined using `implicit` or `given` keywords. The special behaviours were introduced to smoothen migration from Scala 2 to brand new implicits resolution in Scala 3.
This change might also affect some of the projects that use compiler plugins or macros to inspect the implicit argument lists of the function calls - these might require some minor fixes, eg. when filtering symbols by their flags.

<!-- TODO: Create and link docs describing differences between given/implicit -->

## Work on a better scheme for given prioritization

In the [Scala 3.5.0 release notes](https://scala-lang.org/blog/2024/08/22/scala-3.5.0-released.html) we've announced upcoming changes to givens, due to their peculiar problem with prioritization. Currently, the compiler always tries to select the instance with the most specific subtype of the requested type. In the future, it would change to always selecting the instance with the most general subtype that satisfies the context-bound.

Starting from Scala 3.6, code whose behaviour can differ between new and old rules (ambiguity on new, passing on old, or vice versa) will emit warnings, but the old rules will still be applied.
Running the compiler with `-source:3.5` will allow you to temporarily keep using the old rules; with `-source:3.7` or `-source:future` the new scheme will be used.

For the detailed motivation of changes with examples of code that will be easier to write and understand, see our recent blog post - [Upcoming Changes to Givens in Scala 3.7]({{ site.baseurl }}/2024/08/19/given-priority-change-3.7.html).

## Require named arguments for Java-defined annotations

Java-defined annotations don't have an exact constructor representation. The compiler previously relied on the order of the fields to create annotation instance. One possible issue with this representation is the reordering of the fields.
Let's take the following example:

```scala
  public @interface Annotation {
    int a() default 41;
    int b() default 42;
  }
```

Reordering the fields is binary-compatible but it might affect the meaning of `@Annotation(1)`
Starting from Scala 3.6, named arguments are required for Java-defined annotations that define multiple parameters. Java defined annotations with a single parameter named `value` can still be used anonymously.

```Java
  public @interface CanonicalAnnotation {
    String value() default "";
  }
  public @interface CustomAnnotation {
    String param() default "";
  }
```

```Scala
class NoExplicitNames(
  @CanonicalAnnotation() useDefault: String,
  @CanonicalAnnotation(value = "myValue") named: String
  @CanonicalAnnotation("myValue") unnamed: String
)

class ExplicitNamesRequired(
  @CustomAnnotation() useDefault: String,
  @CustomAnnotation(param = "myParam") named: String
  @CustomAnnotation("unnamedParam") invalid: String // error
)
```

The compiler can provide you with automatic rewrites introducing now required names, using `-source:3.6-migration, -rewrite` flags. The rewrites are done on a best-effort basis and should be inspected for correctness by the users.

## Experimental SIP-58 - Named Tuples

Named Tuples have been introduced as experimental in Scala 3.5.0. This feature is now ready to be tested, but is not yet stabilized.
We encourage you to try named tuples and to report your feedback [on the public forum](https://contributors.scala-lang.org/t/pre-sip-named-tuples).
Named Tuples allow you to give meaningful names to tuple elements and use those names during constructing, destructuring, and pattern matching.

```scala
//> using options -experimental -language:experimental.namedTuples
extension [T](seq: Seq[T])
  def partitionBy(predicate: PartialFunction[T, Boolean]): (matching: Seq[T], unmatched: Seq[T]) =
    seq.partition(predicate.unapply(_).isDefined)

@main def onlySmallRealNumbers =
  List(
    (x = 1, y = 0),
    (x = 2, y = 3),
    (x = 0, y = 1),
    (x = 3, y = 0),
  ).partitionBy:
    case (x = real, y = 0) => real < 5
  .matching.map(_.x)
  .foreach(println)
```

This change also introduces improvements to extractors of case classes. You can now define named extractors for a selection of fields, allowing you to unclutter your code from unused variables.

```scala
//> using options -experimental -language:experimental.namedTuples
case class User(id: Int, name: String, surname: String)

extension (values: Seq[User])
  //  Collect user IDs of every entry that has the name matching argument
  def idsWithName(name: String) = values.collect:
    case User(name = `name`, id = userId) => userId
```

Last, but not least, named tuples are opening a new paradigm of metaprogramming by letting you compute structural types without need for macros!
The `Selectable` trait now has a `Fields` type member that can be instantiated to a named tuple.

```scala
//> using options -experimental -language:experimental.namedTuples
class QueryResult[T](rawValues: Map[String, Any]) extends Selectable:
  type Fields = NamedTuple.Map[NamedTuple.From[T], Option]
  def selectDynamic(fieldName: String) = rawValues.get(fieldName)
  
case class City(zipCode: Int, name: String)

@main def Test =
  val query: QueryResult[City] = QueryResult(Map("name" -> "Lausanne"))
  assert(query.name.contains("Lausanne"))
  assert(query.zipCode.isEmpty)
```

You can read more about named tuples in the [dedicated section of Scala 3 reference documentation](https://scala-lang.org/api/3.6.2/docs/docs/reference/experimental/named-tuples.html).

# Whatâ€™s next?

The Scala 3.6.2 will be followed by at least 2 patch releases, during which we will focus on bug fixes and improvements to experimental features based on your feedback.
You can expect Scala 3.6.3 to be released in the middle of January followed by 3.6.4 by the end of Q1 2025.
In Q2 2025 we're planning a new minor release of Scala 3.7 that might bring stabilisation to some of the experimental features. We are encouraging you to test out the experimental features mentioned in this article and share your feedback with the Scala team.

Currently, we are also preparing a Scala 3.3.5 LTS patch release - it would include all backportable changes introduced until Scala 3.5.2. It should be released in January 2025.

# Contributors

Thank you to all the contributors who made this release possible ðŸŽ‰

According to git shortlog -sn --no-merges 3.5.2..3.6.2 these are:

<!-- TODO: Fill me -->
